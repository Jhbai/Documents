## **1\. 進階動態規劃 (Interval, Bitmask, & Digit DP)**

這類問題通常需要將問題空間映射到一個有限狀態機或遞迴結構上。

| 編號 | 題目名稱 | 核心提問 (重點) | 線索 (Constraints & Hints) | 解題思路 (數學與演算法) |
| :---- | :---- | :---- | :---- | :---- |
| **312** | **戳氣球 (Burst Balloons)** | 如何定義子問題，使得子問題之間**相互獨立**？ | **線索：** 若先戳破中間的氣球，左右兩邊會合併，導致邊界條件改變，無法獨立求解。 **限制：** $N \\le 300$，暗示 $O(N^3)$ 複雜度。 | **逆向思維 (Reverse Thinking)：** 不思考「先戳哪個」，而是思考「**最後戳哪個**」。 定義 $dp\[i\]\[j\]$ 為戳破區間 $(i, j)$ 內所有氣球的最大收益。當 $k$ 是最後一個戳破時，問題被完美分割為 $(i, k)$ 與 $(k, j)$，且邊界 $i$ 和 $j$ 依然存在。狀態轉移： $dp\[i\]\[j\] \= \\max\_k (dp\[i\]\[k\] \+ dp\[k\]\[j\] \+ nums\[i\] \\times nums\[k\] \\times nums\[j\])$ |
| **1000** | **合併石頭的最低成本** | 如何將 $N$ 堆合併為 1 堆，且每次只能合併 $K$ 堆？ | **線索：** 每次合併減少 $K-1$ 堆。若 $(N-1) \\pmod{K-1} \\neq 0$，則無解。 **幾何意義：** 這是一個多叉樹的最小權重問題。 | **區間 DP \+ 狀態壓縮：** 定義 $dp\[i\]\[j\]\[m\]$ 為將區間 $\[i, j\]$ 合併成 $m$ 堆的最小成本。 目標是求 $dp\[1\]\[N\]\[1\]$。 轉移方程涉及將區間分割點 $p$ 切開，一部分合併為 1 堆，另一部分合併為 $m-1$ 堆。 |
| **132** | **分割回文串 II** | 最少需要切幾刀，使每個子字串都是回文？ | **線索：** 「最少切割數」暗示 BFS 或一維 DP。 **預處理：** 回文判斷 $O(N)$ 太慢，需 $O(1)$ 查詢。 | **DP \+ 預處理表：** 1\. 先建立 $isPalindrome\[i\]\[j\]$ 表（區間 DP）。 2\. 定義 $f\[i\]$ 為前綴 $s\[0..i\]$ 的最小切割數。 3\. 若 $s\[j..i\]$ 是回文，則 $f\[i\] \= \\min(f\[i\], f\[j-1\] \+ 1)$。 |
| **847** | **訪問所有節點的最短路徑** | 在圖中尋找一條路徑（可重複走），經過所有節點的最短長度。 | **線索：** $N \\le 12$，極小。這暗示複雜度指數級別，與 $2^N$ 有關。 **特徵：** 狀態不僅是「在哪個點」，還有「去過哪些點」。 | **BFS \+ 狀態壓縮 (Bitmask)：** 狀態定義為 $(u, mask)$，其中 $u$ 是當前節點，$mask$ 是已訪問節點的位元集合。 在狀態圖上跑 BFS 最短路。初始狀態為所有 $(i, 1 \\ll i)$ 入隊。 |
| **1125** | **最小的必要團隊** | 集合覆蓋問題 (Set Cover Problem) 的變體：用最少人數覆蓋所有技能。 | **線索：** 技能總數 $\\le 16$。 **代數結構：** 技能集合可以映射為一個整數的二進位表示。 | **DP \+ Bitmask：** 定義 $dp\[mask\]$ 為滿足技能集合 $mask$ 所需的最小人數。 遍歷每個人及其擁有的技能 $skill\\\_mask$，更新： $dp\[mask |
| **698** | **劃分為 k 個相等的子集** | 能否將陣列分割成 $k$ 個總和相等的子集？ | **線索：** 這是 NP-Complete 問題 (Partition Problem)，但數據規模小。 **必要條件：** 總和必須能被 $k$ 整除。 | **回溯法 (Backtracking) \+ 剪枝：** 將數字填入 $k$ 個桶中。關鍵剪枝技巧： 1\. 從大到小排序。 2\. 若當前桶填滿，遞迴下一個桶。 3\. 使用位元遮罩記憶化搜索狀態 (Memoization)。 |
| **233** | **數字 1 的個數** | 計算 $\\le N$ 的整數中，數位 '1' 出現的總次數。 | **線索：** $N$ 很大 ($10^9$)，不能暴力遍歷。 **規律：** 每一位數出現 1 的次數呈現週期性。 | **數位統計 (Digit Counting)：** 逐位分析。對於第 $k$ 位（權值 $10^k$），1 出現的次數取決於高位與低位。 公式化分類討論： 1\. 當前位 $\>1$：受高位影響完全。 2\. 當前位 $=1$：受高位及低位剩餘數影響。 3\. 當前位 $=0$：受高位影響。 |
| **600** | **不含連續 1 的非負整數** | 計算 $\\le N$ 的二進位表示中沒有連續 1 的數的個數。 | **線索：** 「無連續 1」即費氏數列 (Fibonacci) 的性質。 **構造：** 0, 1, 10, 100... | **數位 DP 或 組合數學：** 1\. 預處理費氏數列 $F\[i\]$ 表示長度為 $i$ 的二進位數中無連續 1 的個數。 2\. 從 $N$ 的高位往低位掃描。若遇到連續兩個 1，則剩下的位數可以任意填（受限於無連續1規則），直接加總並停止。 |
| **902** | **最大為 N 的數字組合** | 給定一組數字 $D$，求由 $D$ 組成且 $\\le N$ 的正整數個數。 | **線索：** 這是一個排列計數問題，需考慮「位數小於 $N$」與「位數等於 $N$」兩種情況。 | **數學排列 \+ 數位 DP：** 1\. 位數少於 $N$：直接用 $ |

## **2\. 圖論與網絡流 (Graph Theory & Network Flow)**

這裡關注的是圖的連通性、最短路徑變體與歐拉路徑。

| 編號 | 題目名稱 | 核心提問 (重點) | 線索 (Constraints & Hints) | 解題思路 (數學與演算法) |
| :---- | :---- | :---- | :---- | :---- |
| **787** | **K 站中轉內最便宜的航班** | 有邊數限制的最短路徑問題 (Shortest path with at most $K$ edges)。 | **線索：** 標準 Dijkstra 會失效，因為最短路徑可能邊數過多。 **關鍵：** $K$ 限制了遞迴深度或迭代次數。 | **Bellman-Ford 或 BFS 層次遍歷：** 這是 Bellman-Ford 的典型應用場景。鬆弛操作 (Relaxation) 最多執行 $K+1$ 輪。 $dist\[v\] \= \\min(dist\[v\], prev\\\_dist\[u\] \+ w)$。需保存上一輪狀態以避免同輪次多次更新。 |
| **743** | **網絡延遲時間** | 訊號從源點傳播到所有節點所需時間（即離源點最遠的最短路徑）。 | **線索：** 正權有向圖，單源最短路徑。 **目標：** $\\max(\\text{shortest\\\_path}(u))$。 | **Dijkstra 演算法：** 使用 Min-Heap 實作標準 Dijkstra。若有節點無法到達，回傳 \-1。 |
| **332** | **重新安排行程** | 給定機票，尋找一條路徑用光所有機票（邊），且字典序最小。 | **線索：** 「用光所有機票」$\\rightarrow$ 經過每一條邊恰好一次 $\\rightarrow$ **歐拉路徑 (Eulerian Path)**。 **特徵：** 起點固定為 JFK。 | **Hierholzer 演算法 (DFS)：** 因為保證有解，這是一個半歐拉圖或歐拉圖。 使用 DFS 遍歷，**當節點無路可走時，將其加入路徑堆疊**（逆序輸出）。貪心選擇字典序小的鄰居先走。 |
| **2097** | **合法配對的有效排列** | 將數字對 $\[start, end\]$ 排列，使 $end\_{i-1} \== start\_i$。 | **線索：** 數字對視為有向邊 $u \\to v$。 **目標：** 尋找歐拉路徑或歐拉迴路。 | **歐拉路徑 (Hierholzer's Algorithm)：** 1\. 計算所有點的 In-degree 和 Out-degree。 2\. 找起點：$Out \- In \= 1$ 的點。若無，任意點皆可（迴路）。 3\. 跑 Hierholzer 算法構建路徑。 |
| **1192** | **查找集群內的關鍵連接** | 找出圖中的所有「橋 (Bridge)」。(移除該邊後圖不連通) | **線索：** $N$ 高達 $10^5$，必須是 $O(V+E)$ 線性解法。 **幾何意義：** 不在任何「環 (Cycle)」上的邊就是橋。 | **Tarjan 演算法 (DFS)：** 維護兩個陣列：$dfn$ (發現時間) 和 $low$ (能回溯到的最早節點)。 若 $low\[child\] \> dfn\[parent\]$，表示 $child$ 無法透過非父節點路徑回到 $parent$ 或更早的點，故 $(parent, child)$ 為橋。 |

## **3\. 計算幾何與掃描線 (Computational Geometry)**

幾何問題通常轉換為排序問題或圖論問題。

| 編號 | 題目名稱 | 核心提問 (重點) | 線索 (Constraints & Hints) | 解題思路 (數學與演算法) |
| :---- | :---- | :---- | :---- | :---- |
| **587** | **安裝柵欄** | 尋找二維點集的凸包 (Convex Hull)。 | **線索：** 需要圍住所有點。 **邊界條件：** 共線的點是否包含？ | **Monotone Chain 或 Jarvis Algorithm：** 利用**向量外積 (Cross Product)** 判斷轉向（左轉、右轉、直行）。Monotone Chain 先將點排序，分別構建上凸殼與下凸殼。 |
| **218** | **天際線問題** | 給定多個矩形，求合併後的輪廓線關鍵點。 | **線索：** 關鍵點出現在矩形的左邊界或右邊界。 **技巧：** 將二維圖形降維成一維事件點。 | **掃描線 (Sweep Line) \+ Max Heap：** 1\. 將每個建築物拆解為兩個事件：$(L, \-H)$ 和 $(R, H)$。 2\. 依 $x$ 座標排序。 3\. 遍歷事件：左邊界將高度入堆，右邊界將高度移除（或 Lazy removal）。 4\. 堆頂最大值變化時，紀錄關鍵點。 |
| **223** | **矩形面積** | 計算兩個矩形覆蓋的總面積（需扣除重疊）。 | **線索：** 包含排斥原理 (Inclusion-Exclusion Principle)。 | **幾何投影：** 總面積 \= 面積 A \+ 面積 B \- 重疊面積。 重疊寬度 \= $\\max(0, \\min(right\_1, right\_2) \- \\max(left\_1, left\_2))$。 |

## **4\. 系統設計、並行與貪心 (System Design & Others)**

這類題目考察資料結構的綜合應用與作業系統概念。

| 編號 | 題目名稱 | 核心提問 (重點) | 線索 (Constraints & Hints) | 解題思路 (數學與演算法) |
| :---- | :---- | :---- | :---- | :---- |
| **355** | **設計推特** | 實作發文、關注與獲取最新 10 則動態 (News Feed)。 | **線索：** News Feed 需要合併多個用戶的時間軸，且需按時間排序。 **核心難點：** 讀取效率。 | **Pull Model (Merge K Sorted Lists)：** 每個用戶維護一個推文鏈表 (Linked List)。 獲取 Feed 時，將所有關注對象的鏈表頭放入 **Max Heap**，動態取出最新的 10 篇 (類似合併 K 個有序陣列)。 |
| **146** | **LRU 快取機制** | 實作 $O(1)$ 的 get 和 put，並具備容量限制與淘汰機制。 | **線索：** $O(1)$ 查找 $\\rightarrow$ HashMap。 $O(1)$ 插入/刪除/移動順序 $\\rightarrow$ Doubly Linked List。 | **Hash Map \+ 雙向鏈表：** Map 儲存 key \-\> Node 指標。 List 維護時序：最新訪問移到頭部，滿了刪除尾部。 這是一個經典的複合數據結構設計。 |
| **1114** | **按序列印** | 確保三個函數按特定順序執行，即使它們在不同執行緒中被呼叫。 | **線索：** 非同步執行，需要同步機制 (Synchronization)。 | **信號量 (Semaphore) 或 Mutex：** 建立依賴鏈：Job 2 等待 Job 1 完成 (Signal 1)，Job 3 等待 Job 2 完成 (Signal 2)。 |
| **1115** | **交替列印 FooBar** | 兩個執行緒交替輸出 "Foo" 和 "Bar" $N$ 次。 | **線索：** 這是典型的生產者-消費者 (Producer-Consumer) 模型，緩衝區大小為 1。 | **雙信號量 (Two Semaphores)：** Sem\_Foo 初始為 1，Sem\_Bar 初始為 0。 Foo 執行緒：Acquire(Foo) \-\> Print \-\> Release(Bar)。 Bar 執行緒：Acquire(Bar) \-\> Print \-\> Release(Foo)。 |
| **51** | **N 皇后** | 在 $N \\times N$ 棋盤放 $N$ 個皇后，使其互不攻擊。 | **線索：** 行、列、對角線 ($x+y$, $x-y$) 均不能重複。 | **回溯法 \+ 空間優化：** 使用三個集合 (Sets) 或布林陣列紀錄：列佔用、主對角線佔用、副對角線佔用。逐行嘗試放置。 |
| **435** | **無重疊區間** | 移除最少區間，使剩餘區間不重疊。 | **線索：** 區間排程問題 (Interval Scheduling)。 **目標：** 保留最多區間。 | **貪心算法 (Greedy)：** 優先保留「結束時間最早」的區間，因為它留給後面的空間最大。 按 End Time 排序，遍歷並剔除與前一個保留區間重疊者。 |
| **45** | **跳躍遊戲 II** | 到達最後索引的最少跳躍次數。 | **線索：** 總是求最優解 $\\rightarrow$ BFS 概念，但可用貪心優化。 **關鍵：** 每一步能覆蓋一個範圍。 | **貪心 (Implicit BFS)：** 維護當前跳躍步數能到達的最遠邊界 current\_end 和下一跳能到的最遠邊界 farthest。 遍歷 $i$，更新 farthest。當 $i$ 到達 current\_end 時，步數+1，更新 current\_end \= farthest。 |

### **總結 (Summary)**

從這份列表中我們可以看出幾個高階模式：

1. **狀態壓縮 (Bitmask)** 是處理小規模集合 ($N \\le 20$) 最優化問題的強大工具 (如 847, 1125)。  
2. **逆向思維** 在動態規劃中至關重要 (如 312 戳氣球)。  
3. **圖論轉換** 是許多看起來不像圖論問題的解法 (如 332 行程重建其實是歐拉路徑)。  
4. **不變量** (如 LRU 的時序、幾何的凸性) 是設計演算法的核心依據。
