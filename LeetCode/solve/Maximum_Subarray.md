# **LeetCode 53\. Maximum Subarray 題目深度解析**

LeetCode 第 53 題 **Maximum Subarray**（最大子陣列）是演算法面試中最經典的題目之一。它不僅考察對陣列（Array）的操作，更是理解**動態規劃 (Dynamic Programming)** 與 **貪婪演算法 (Greedy)** 的入門必經之路。

## **1\. 題目敘述**

給定一個整數陣列 nums，請找出一個具有最大和的**連續子陣列**（子陣列最少包含一個元素），並返回其最大和。

* **範例 1**：  
  * 輸入：nums \= \[-2,1,-3,4,-1,2,1,-5,4\]  
  * 輸出：6  
  * 解釋：連續子陣列 \[4,-1,2,1\] 具有最大的和 6。  
* **範例 2**：  
  * 輸入：nums \= \[1\]  
  * 輸出：1  
* **範例 3**：  
  * 輸入：nums \= \[5,4,-1,7,8\]  
  * 輸出：23

**限制條件**：

1. $1 \\le \\text{nums.length} \\le 10^5$  
2. $-10^4 \\le \\text{nums\[i\]} \\le 10^4$

## **2\. 測驗目的**

這道題目的主要目的是考察開發者是否具備以下能力：

* **優化思維**：能否從 $O(n^2)$ 或 $O(n^3)$ 的暴力解法優化到 $O(n)$ 的線性解法。  
  * **為何需要優化？** 根據限制條件 $n=10^5$，若使用 $O(n^2)$ 的暴力雙層迴圈，運算次數將達 $10^{10}$ 次，這在一般面試環境中會因超時（TLE）而失敗。  
  * **暴力解法分析**：  
    * $O(n^3)$ **邏輯**：使用三層迴圈。第一層決定子陣列起點 $i$，第二層決定終點 $j$，第三層則負責「重新計算」從 $i$ 到 $j$ 之間所有元素的總和。  
    * $O(n^2)$ **邏輯**：使用雙層迴圈。在固定起點 $i$ 後，隨著終點 $j$ 向後移動，我們可以直接將前一個狀態的和 sum(i, j-1) 加上當前的 nums\[j\]，省去第三層迴圈。  
  * **複雜度直覺：如何從題目思索出** $O(n)$ **邏輯？**  
    1. **觀察重複性**：題目要求「連續」子陣列。當我們計算以 $i$ 結尾的和時，其實已經包含了部分以 $i-1$ 結尾的計算結果。  
    2. **關鍵決策點**：在陣列的任何一個位置，我只有兩個選擇：  
       * 「繼承」之前的成果：如果之前的累加值是**正數**，對我有幫助，我就接下去。  
       * 「拋棄」之前的負累：如果之前的累加值是**負數**，對我只有副作用，我直接從現在這個數字重新開始（另起一個子陣列）。  
    3. **邏輯推導過程：從題目敘述到決策點**  
       * **題目關鍵字 1：連續 (Subarray)** \-\> 這代表我們不能跳著選。如果我要算當前數字 nums\[i\] 能貢獻的最大值，它**必須**緊接著前一個狀態 i-1。  
       * **題目關鍵字 2：最大 (Maximum Sum)** \-\> 既然目標是最大化，那麼對於 nums\[i\] 來說，如果 i-1 之前的累加結果（我們稱為 current\_sum）是大於 0 的，加上它一定會讓我的總值變大；反之，如果它是負的，加上它只會讓我變小。  
       * **結論**：既然我要最大化，我當然只在「前人的遺產為正」時才接受它。這種從局部（當下數字）的最優選擇出發，最終達成全域最優的過程，就是從題目限制中自然聯想到的 $O(n)$ 邏輯。  
    4. **單向性**：因為只需要從左到右掃描一遍，並且在每個點都做上述的「最優選擇」，我們就能在 $O(n)$ 時間內得到答案。這本質上是將「全域搜尋」轉化為「局部即時決策」。  
* **子問題分解**：理解如何將「全域最大值」轉化為「以當前位置為結維的最大值」。  
* **邊界處理**：如何處理包含負數的陣列（例如全為負數的情況）。

## **3\. 思路邏輯分析**

題目的核心要求是找到一個**連續**的子陣列，使其和最大。

### **核心邏輯點：**

當我們遍歷陣列到索引 i 時，我們面臨一個選擇：

1. **加入前面的隊伍**：將 nums\[i\] 加入到以 i-1 為結尾的最大子陣列中。  
2. **另起爐灶**：如果前面的累加結果已經變成了負數，那麼加上它只會讓當前的值變小，不如直接從 nums\[i\] 重新開始計算。

這就是 **Kadane's Algorithm** 的核心思維：**「如果之前的累加對我有負面影響，我就拋棄它。」**

### **解法三：分治法 (Divide and Conquer)**

這是題目進階要求（Follow up）提到的方法。將陣列切半，最大和可能出現在：
1. 左半部  
2. 右半部  
3. 橫跨中點（從中點向左右擴展）
時間複雜度為 $O(n \\log n)$。

## **4\. 總結比較**

| 方法 | 時間複雜度 | 空間複雜度 | 備註 |
| :---- | :---- | :---- | :---- |
| **暴力法 (Brute Force)** | $O(n^2)$ | $O(1)$ | 雙層迴圈，易超時 |
| **Kadane's Algorithm** | $O(n)$ | $O(1)$ | **最優解**，面試必備 |
| **分治法 (Divide & Conquer)** | $O(n \\log n)$ | $O(\\log n)$ | 適合處理更複雜的區間查詢問題 |

