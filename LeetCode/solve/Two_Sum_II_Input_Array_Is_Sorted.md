# **LeetCode 167\. Two Sum II \- Input Array Is Sorted (輸入陣列已排序之兩數之和)**

## **1\. 題目敘述 (Problem Description)**

題目：  
給定一個下標從 1 開始 (1-indexed) 的整數陣列 numbers，該陣列已按非遞減順序 (non-decreasing order) 排列。請你從陣列中找出兩個數，滿足這兩個數相加等於一個特定的目標數 target。  
令這兩個數為 numbers\[index1\] 和 numbers\[index2\]，其中 1 \<= index1 \< index2 \<= numbers.length。

請回傳這兩個數的下標值 index1 和 index2，並以長度為 2 的整數陣列 \[index1, index2\] 的形式返回。

**限制與要求：**

* 你可以假設每個輸入**恰好只有一個解**。  
* 你**不可以**使用同一個元素兩次。  
* 你的解法必須僅使用**常數級的額外空間** (即 Space Complexity 為 $O(1)$)。

**範例 1：**

* **輸入：** numbers \= \[2,7,11,15\], target \= 9  
* **輸出：** \[1,2\]  
* **解釋：** 2 與 7 之和為 9。因此 index1 \= 1, index2 \= 2。返回  (1, 2\)  
* **輸入：** numbers \= \[2,3,4\], target \= 6  
* **輸出：** \[1,3\]  
* **解釋：** 2 與 4 之和為 6。因此 index1 \= 1, index2 \= 3。返回 (1,3)

**範例 3：**

* **輸入：** numbers \= \[-1,0\], target \= \-1  
* **輸出：** \[1,2\]  
* **解釋：** \-1 與 0 之和為 \-1。因此 index1 \= 1, index2 \= 2。返回 (1,2)

## **2\. 測驗目的 (Educational Purpose)**

這道題目主要測試面試者以下幾個核心能力：

1. **利用「已排序」特性優化演算法的能力：**  
   * 這是與 LeetCode 第 1 題 (Two Sum) 最大的不同。第 1 題是無序陣列，通常使用 Hash Map 來達到 $O(N)$ 時間複雜度，但空間複雜度也是 $O(N)$。  
   * 本題強調陣列**已排序**，且要求空間複雜度為 $O(1)$，這是在暗示我們不能依賴 Hash Map，必須尋找更節省空間的方法。  
2. **雙指標 (Two Pointers)技巧的掌握：**  
   * 這是處理排序陣列搜尋問題的經典技巧。透過縮小搜索區間來逼近答案。  
3. **邊界條件與索引處理：**  
   * 題目特別強調是 **1-indexed**，這是實作細節上的陷阱，回傳結果時需要注意索引轉換 (通常程式語言是 0-indexed)。  
   * **解題思路上的含意：** 這並不改變「雙指標」的核心演算法邏輯，但它引入了一個「座標映射」的步驟。  
     * **內部邏輯：** 在程式碼實作時，我們依然使用 0-based 的邏輯來操作陣列 (因為這是語言特性，方便讀取)。  
     * **外部接口：** 在**最終回傳結果**時，必須手動執行 \+1 的映射操作 (Mapping index $\\rightarrow$ index \+ 1)。這是一個典型的「實作細節陷阱」。

4. ### **💡 關鍵字解析：非遞減順序 (Non-decreasing Order)**    **看到這個關鍵字，你應該立刻聯想到以下性質與解題線索：**

   1. **定義**：陣列元素從小到大排列，但**允許重複數值** (例如 \[1, 2, 2, 3\])。這與「嚴格遞增 (Strictly Increasing)」不同，後者不允許重複。  
   2. **單調性 (Monotonicity)**：這是解題的核心。  
      * **往右看 (Index 增加)**：數值只會變大或持平。  
      * **往左看 (Index 減少)**：數值只會變小或持平。  
   3. **解題暗示**：  
      * **方向性與雙指標 (Two Pointers)**：正是因為這個順序，給了我們移動指標的「確定性」。若當前和 sum \> target，為了讓總和變小，我們**非常確定**唯一選擇是讓右指標左移 (選較小的數)；反之亦然。如果陣列是無序的，我們就無法知道移動哪個指標能達到目的。  
      * **二分搜尋 (Binary Search)**：有序陣列允許 $O(\\log N)$ 的查找。雖然此題雙指標 $O(N)$ 更優，但看到「Sorted」想到「Binary Search」是一個標準且必要的直覺聯想。

## **3\. 思路邏輯 (Thought Process)**

我們如何從題目敘述推導出最佳解法？

### **思考 1：暴力法 (Brute Force) \- 直覺但無效**

* **想法：** 使用兩層迴圈，列舉所有可能的數對 (i, j)，檢查 numbers\[i\] \+ numbers\[j\] \== target。  
* **分析：** 時間複雜度為 $O(N^2)$。對於此題的數據規模來說太慢，且完全沒有利用到「已排序」這個關鍵資訊。

### **思考 2：二分搜尋法 (Binary Search) \- 稍微優化**

* **想法：** 固定一個數字 x，然後在它右邊的剩餘陣列中，用二分搜尋法找 target \- x。  
* **詳細操作邏輯**：  
  1. 使用一個迴圈遍歷陣列，假設當前選定的數字為 numbers\[i\]。  
  2. 計算我們需要的另一個數字 (互補數)：needed \= target \- numbers\[i\]。  
  3. 因為陣列是**已排序**的，我們不需要像暴力法那樣線性掃描，而是可以在下標 i \+ 1 到 end 的範圍內，執行**二分搜尋 (Binary Search)** 來尋找這個 needed。  
* **為什麼會這樣想？** 看到題目關鍵字 **"Input Array Is Sorted" (陣列已排序)**，這是最直接的提示。在已排序的資料中尋找特定值，最直覺且標準的高效解法就是二分搜尋。這是一種將「尋找」動作從 $O(N)$ 優化為 $O(\\log N)$ 的標準反射動作，而因為外層仍需要遍歷每一個數字，所以整體的複雜度確實是 $O(N \\log N)$。  
* **分析：**  
  * **外層迴圈**：遍歷每個元素固定為第一個數，需執行 $N$ 次。  
  * **內層搜尋**：對剩餘元素進行二分搜尋，需時 $O(\\log N)$。  
  * **總時間複雜度**：$O(N) \\times O(\\log N) \= O(N \\log N)$。  
  * **空間複雜度**：$O(1)$。  
  * **結論**：雖然比暴力法 $O(N^2)$ 快，但仍不如雙指標法的 $O(N)$ 高效。

### **思考 3：雙指標法 (Two Pointers) \- 最佳解**

* **關鍵邏輯：**  
  * 因為陣列是**排序**的 (小 $\\rightarrow$ 大)。  
  * 如果我們選取最小的數 (左端點 left) 和最大的數 (右端點 right) 相加：  
    * 若 sum \> target：表示總和太大，我們需要讓總和變小。因為 left 已經是最小了，只能將 right 向左移 (選一個比較小的數)。  
    * 若 sum \< target：表示總和太小，我們需要讓總和變大。因為 right 已經是最大了，只能將 left 向右移 (選一個比較大的數)。  
    * **持續逼近 (Iterative Approach)**：這不是一次性的判斷，而是一個**持續的迴圈 (Loop)**。  
      * 只要算出來的總和 **太小**，我們就 **持續讓 left 向右移**，試圖增大總和。  
      * 只要算出來的總和 **太大**，我們就 **持續讓 right 向左移**，試圖減小總和。  
      * 透過這種方式，我們不斷縮小搜尋範圍，最終必然會命中目標 (因為題目保證有解)。  
    * 若 sum \== target：找到了！

#### **🔍 為什麼指標不用「回頭」？**

你可能會問：**「當總和太小需要變大時，為什麼我能確定是 left 往右移？難道不能把 right 往右移回去找更大的數嗎？」**

這是一個非常重要的邏輯問題。答案在於\*\*「歷史軌跡」\*\*：

1. **單向性**：在這個演算法中，left **只會往右**，right **只會往左**。它們絕對不會回頭。  
2. **為什麼不能把 right 往右移？**  
   * right 是從最右邊（最大值）開始一路往左走的。  
   * right 離開某個位置（例如 index k）往左移的原因，是因為**當時** numbers\[left\] \+ numbers\[k\] 已經 **\> target**（太大）了。  
   * 注意，當時的 left 比現在的 left 還要小（或相等）。  
   * 如果當時「小 left \+ numbers\[k\]」都已經太大了，現在你用一個「更大的 left \+ numbers\[k\]」，總和只會**爆得更大**，完全不可能等於 target。  
3. **結論**：所有 right 曾經走過並拋棄的右邊區域，都是被證明「對於當前及未來的 left 來說都太大」的禁區。因此，想讓總和變大，**唯一**的選擇就是移動 left。  
* **分析：**  
  * 每個元素最多只被訪問一次。  
  * 時間複雜度：$O(N)$。  
  * 空間複雜度：$O(1)$ (只用了兩個變數)。  
  * **結論：** 這是本題的標準最佳解。
