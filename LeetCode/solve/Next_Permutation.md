# **LeetCode 31\. Next Permutation (下一個排列)**

在組合數學中，排列的「字典序」（Lexicographical Order）就像字典中單詞的排序一樣。這道題目要求我們找到給定整數序列在字典序中的下一個更大排列。

### **什麼是字典序？**

字典序是一種排序方法，其規則源自於我們查閱字典的方式：

1. **比較順序**：從序列的左側（高位）開始逐位比較。  
2. **大小判定**：在第一個不同的位置上，數值較小的序列在字典序中排在前面。例如：  
   * 在數字序列中，\[1, 2, 3\] 排在 \[1, 3, 2\] 之前，因為在第二個位置上 $2 \< 3$。  
   * 這與數字的大小直覺一致：$123 \< 132$。  
3. 排列層次：對於一組數字（如 1, 2, 3）的所有排列，字典序從小到大依序為：  
   \[1, 2, 3\], \[1, 3, 2\], \[2, 1, 3\], \[2, 3, 1\], \[3, 1, 2\], \[3, 2, 1\]。

## **1\. 題目敘述**

實現一個函式，將給定的數字序列重新排列成字典序中下一個更大排列。

* 如果不存在下一個更大的排列（即該序列已經是降序排列，如 \[3, 2, 1\]），則必須將其重新排列為最小的排列（即升序排列，如 \[1, 2, 3\]）。  
* **限制條件**：必須「原地」（In-place）修改，且只能使用常數級的額外空間。  
  * 從限制條件看時間複雜度要求：  
    通常要求 $O(1)$ 額外空間的題目，暗示了我們不能使用如「生成所有排列再排序」這種需要大量空間的方法。生成全排列的時間複雜度是 $O(N\!)$，這可以用乘法原理來解釋：  
    * 第一個位置有 $N$ 種選擇。  
    * 第二個位置剩下 $N-1$ 種選擇。  
    * 依此類推，總排列組合數為 $N \\times (N-1) \\times (N-2) \\times \\dots \\times 1 \= N\!$。  
    * 當 $N=10$ 時，$10\! \= 3,628,800$；當 $N=20$ 時，數值已達約 $2.43 \\times 10^{18}$，在計算機科學中這被視為「階乘級增長」，效率極低。

而「原地修改」要求我們直接在原陣列操作，這通常與雙指針或單次/多次掃描相關。結合 LeetCode 一般對陣列長度（通常 $N \\le 10^4$ 或更高）的限制，這類問題的最優解通常被期望在 $O(N)$ 時間複雜度內完成。

**範例：**

* \[1, 2, 3\] $\\rightarrow$ \[1, 3, 2\]  
* \[3, 2, 1\] $\\rightarrow$ \[1, 2, 3\]  
* \[1, 1, 5\] $\\rightarrow$ \[1, 5, 1\]

## **2\. 測驗目的**

這題的核心目的在於考察開發者是否能觀察出「進位」的邏輯。與整數加法類似，當我們想要得到下一個較大的數，我們會試圖修改儘可能「低位」（右側）的數字，以保證增量最小。

### **什麼是這裡的「進位邏輯」？**

在一般的十進制加法中（例如 $129 \+ 1$），當低位數（個位）達到最大值 $9$時，我們必須向高位（十位）進一，並將低位重置為最小的 $0$。

在排列問題中，邏輯非常相似：

1. **找出「滿位」的部分**：從右側向左看，只要數字是遞增的（如 ...2, 9, 7, 5 中的 9, 7, 5），代表這部分已經是最大排列，無法再透過內部調整變得更大。這就像是十進制中已經達到「$9$」的位數。  
2. **尋找「進位點」**：第一個打破遞增規律的數字（上述例子中的 2）就是我們的 **Pivot**。我們需要從右側找一個比 2 稍微大一點點的數字來替換它，完成「進位」。  
3. **最小化增量**：進位後，為了讓整體數值增加最少，進位點後方的數字必須重新排列成最小的「升序」狀態（就像進位後個位要回歸為 $0$）。

具體考點包括：

* **觀察規則能力**：如何定義「下一個」排列？ 所謂的「下一個」排列，是指在所有大於當前排列的集合中，數值最小（字典序最接近）的那一個。這意味著：  
  * 我們必須改變儘可能靠右的數位，以保持高位數不變。  
  * 我們交換的兩個數，其差值應在保證「變大」的前提下儘可能小。  
  * 交換後，後綴部分必須調整為最小排列（升序）。  
* 雙指針運用：如何高效地在數組中尋找目標元素。  
  從題目要求中，我們可以觀察到雙指針的需求：  
  * **掃描方向性**：由於要找「下一個更大」，我們必須由右（低位）向左（高位）掃描來尋找第一個可交換點。這通常需要一個指標來定位「轉折點」。  
    * **何謂轉折點 (Pivot)？也就是所謂的「進位起始點」。** 在字典序演算法中，轉折點是指從右往左看時，第一個出現「數值下降」的位置。這就像是找到數字中還沒「滿位」的最低位。例如在 \[1, 5, 8, 4, 7, 6, 5, 3, 1\] 中，右側的 7, 6, 5, 3, 1 是降序，代表已經「滿位」無法再變大，直到遇到 4 才下降。因此 4 就是轉折點。動到這個點就相當於執行「進位」，能讓我們產生下一個更大的序列。  
  * **範圍定位**：當找到轉折點後，我們又需要另一個指標在轉折點右側的範圍內尋找「最小的大數」。  
    * **何謂最小的大數 (Successor)？** 為了讓進位後的增量最小，我們不應該隨便拿一個比轉折點大的數來交換。我們要找的是：在所有「大於轉折點」的數當中，「最小」的那一個。例如轉折點是 4，右側有 7, 6, 5，雖然它們都比 4 大，但我們應該選 5。這樣進位後的開頭數字增加最少，最接近原序列。  
  * **區間操作**：最後的反轉操作（Reverse）是典型的雙指針對撞應用（Left 與 Right 指標向中間靠攏並交換），以達到 $O(1)$ 空間複雜度。  
* **邊界處理**：當序列已經是最大值時時的特殊處理。

## **3\. 思路邏輯與步驟**

要找到「下一個」更大的排列，我們的目標是將序列中右側的一個「較小數」與其右側的一個「較大數」交換，且這個「較小數」的位置要儘可能靠右。

### **核心演算法步驟：**

1. 從右向左找第一個下降點 (Pivot)：  
   從倒數第二個元素開始向左遍歷，找到第一個滿足 $nums\[i\] \< nums\[i \+ 1\]$ 的索引 $i$。  
   * 這意味著 $nums\[i+1 \\dots n-1\]$ 這部分是降序排列的，已經是該部分的最大排列。  
   * 如果找不到（即 $i \< 0$），說明整個序列都是降序的，直接跳到步驟 4。  
2. 從右向左找第一個大於 Pivot 的數 (Successor)：  
   在 $nums\[i+1 \\dots n-1\]$ 中，從右向左找到第一個滿足 $nums\[j\] \> nums\[i\]$ 的索引 $j$。這個 $nums\[j\]$ 就是大於 $nums\[i\]$ 的最小數。  
3. 交換 (Swap)：  
   交換 $nums\[i\]$ 與 $nums\[j\]$。  
4. 反轉後綴 (Reverse)：  
   此時 $nums\[i+1 \\dots n-1\]$ 依然保持著降序特性。為了讓整體增量最小，我們需要將這部分改為升序排列，即直接將其反轉。

## **4\. 複雜度分析**

* **時間複雜度**：$O(N)$。我們最多對數組進行兩次遍歷（找 $i$ 和 找 $j$），以及一次反轉操作，所有操作均為線性時間。  
* **空間複雜度**：$O(1)$。僅使用了常數個指標變數，符合題目原地修改的要求。
