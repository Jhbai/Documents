# **LeetCode 1: Two Sum**

### **一、 測驗核心：這題在考什麼？**

這道題目看似簡單，但實際上是在測驗開發者對於以下核心觀念的掌握程度：

* **時間複雜度優化（Time Complexity）：** 從最直觀的「暴力解」（Brute Force, $O(n^2)$）優化到「雜湊表解」（Hash Table, $O(n)$）的能力。  
* **空間與時間的權衡（Space-Time Tradeoff）：** 是否懂得利用額外的空間（如建立 Map 或 Dictionary）來換取執行速度的提升。  
* **資料結構的選擇與應用：** 是否熟悉如何在程式語言中使用雜湊表（Hash Table / Map / Dictionary），並理解其尋找元素（Look-up）的時間複雜度為 $O(1)$ 的優勢。  
* **邊界條件與索引處理：** 如何正確存取陣列的索引（Index），以及處理題目要求的「不可重複使用同一個元素」的限制。

### **二、 出題意圖：為什麼這樣出題？**

Two Sum 被設計為入門首選，有其深刻的教育意義：

1. 模擬真實開發場景：  
   實務上我們經常需要在大量資料中尋找特定匹配項。這題考驗你是否能建立「索引」的概念來加速搜尋。  
2. 引導逆向思維：  
   題目給的是 $A \+ B \= Target$，這題的解題關鍵在於將其轉化為尋找 $B \= Target \- A$。這種「將問題目標轉換」的思維是解決許多困難演算法的基礎。  
   * 為什麼想到把「補數」放到 Hash Table？  
     當我們遍歷到數字 $A$ 時，我們會問：「陣列中是否還有另一個數字能跟我配對？」與其每次都重新掃描整個陣列尋找 $B$，不如將走過的路徑「記錄」下來。Hash Table 的本質是「記憶」，我們把已經看過的數字存起來，當後面的數字需要找「補數」時，只要一瞬間 ($O(1)$) 就能知道那個補數是否在之前的紀錄中。  
   * 為什麼 Value 是放 index 而不是數值本身？  
     這與題目的「回傳要求」直接相關。題目最終要求回傳的是索引值 \[index1, index2\]。如果我們在 Hash Table 的 Value 只存布林值（是否存在），我們雖然知道找到了答案，卻無法得知那個「補數」到底在哪個位置。因此，將「數值」作為 Key（用於快速比對補數），將「索引」作為 Value（用於最後回傳結果），是最符合邏輯的映射設計。

### **三、 題目的關鍵字（Keywords）**

閱讀題目時，以下幾個詞彙是決定解題策略的關鍵：

* **exactly one solution（恰好一個解）：** 這代表你不必考慮「無解」或「多個解」的複雜情況，只要找到一組即可結束程式。  
* **may not use the same element twice（不可重複使用同一個元素）：** 這是重要的限制條件。在遍歷時，你必須確保目標數不是當前正在處理的這個數字（即索引必須不同）。  
* **return the indices（回傳索引）：** 題目要求的不是回傳數值，而是回傳索引值。這意味著在存儲中間過程時，必須同時記錄「數值」與「其對應的索引」。  
* **Integer Array（整數陣列）：** 提示了數據類型，通常暗示可以利用雜湊表來處理，因為整數作為鍵值（Key）的效率極高。  
* **Constraints / 資料範圍（Data Range）：** 題目通常標註陣列長度可達 $10^4$。在面試或競爭程式中，當 $N$ 達到這個量級，$O(N^2)$ 的暴力解運算次數將高達 $10^8$，極大機率會超時（Time Limit Exceeded）。這暗示了面試官期望看到的是 $O(N)$ 或 $O(N \\log N)$ 的優化解法。

### **四、 總結**

透過 Two Sum，最重要的一個概念是：**當你需要频繁查找某個元素時，請優先考慮雜湊表。** 這是一個能夠將尋找時間從 $O(n)$ 降至 $O(1)$ 的魔術工具。
