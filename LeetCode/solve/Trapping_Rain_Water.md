# **LeetCode 42\. Trapping Rain Water 深度統整**

## **1\. 題目敘述 (Problem Description)**

給定一個非負整數陣列 height，其中每個元素代表寬度為 1 的柱子高度。請計算在下雨之後，這些柱子之間總共可以接住多少單位的雨水。

* **輸入**：height \= \[0,1,0,2,1,0,1,3,2,1,2,1\]  
* **輸出**：6  
* **解釋**：上述的高度圖可以形成多個「凹槽」，雨水會填滿這些凹槽。

## **2\. 測驗目的與核心概念**

這道題目被歸類為 **Hard** 難度，主要考察面試者對於以下能力的掌握：

* **觀察規律能力**：如何將物理上的「接水」轉化為數學模型。  
  * **聯想邏輯**：當我們在現實中看到一個坑洞能接水，是因為它左右兩邊都有比底部更高的「邊界」。  
  * **轉化過程**：  
    1. **最小瓶頸感應**：想像你在其中一個格子 $i$，你往左看會看到一排牆，最高的是 $L$；往右看也會看到一排牆，最高的是 $R$。  
    2. **木桶理論**：這格能接多少水，不取決於最高的牆，而是取決於左右兩邊「較矮」的那面牆（即 $\\min(L, R)$）。  
    3. **扣除自身高度**：如果這面較矮的牆比你腳下的地板 $height\[i\]$ 還高，那差值就是水深；如果比你矮，水就流走了，積水為 0。  
* **空間換時間 (DP)**：利用陣列預處理來優化暴力解。  
  * **聯想邏輯**：  
    1. **發現重複計算**：在暴力解中，我們每走到一個格子 $i$，都要重新往左掃描一次找 $L$，往右掃描一次找 $R$。這意圖著當我們處理格子 $i+1$ 時，大部分的掃描路徑其實是重複的。  
    2. **狀態緩存需求**：如果我們能「預先知道」每個位置左側最高的山峰在哪，以及右側最高的山峰在哪，我們就能在 $O(1)$ 時間內算出該格水量。  
    3. **遞迴關係轉化**：$i$ 位置的左側最大值，其實就是 「$i-1$ 位置的左側最大值」與「自身高度」的較大者。這種「利用前面結果推導後續結果」的特性，正是動態規劃 (DP) 的典型應用。  
* **雙指標 (Two Pointers)**：進一步將空間複雜度優化至 $O(1)$。  
  * **聯想邏輯**：  
    1. **觀察 DP 冗餘**：在 DP 解法中，我們雖然用了兩個陣列，但對於某一格 $i$ 而言，我們其實只在意 $\\min(left\\\_max, right\\\_max)$。  
    2. **局部已知資訊**：如果我們使用左右兩個指標 left 和 right 向中間靠攏，且已知 left\_max 為左方目前的最高值，right\_max 為右方目前的最高值。  
    3. **確定瓶頸**：當 height\[left\] \< height\[right\] 時，我們可以肯定，對於 left 位置來說，其右側一定存在一個比 left\_max 更大的牆（至少有目前的 height\[right\] 撐著），因此 left 的接水瓶頸一定就在 left\_max 這一側。  
    4. **捨棄全局陣列**：既然只要確定其中一側是短板就能結算，我們就不需要完整的 $O(n)$ 預處理陣列，只需維護兩個變數隨時記錄左右兩端的極大值即可。  
    5. **動態維護邏輯**：  
       * **同步更新**：當指標 left 右移時，我們立即更新 left\_max \= max(left\_max, height\[left\])；同理，當 right 左移時更新 right\_max。  
       * **安全結算**：只要 left\_max \< right\_max，我們就能確定「左側高度」是當前的真瓶頸。即便我們不知道 right 右側完整的分布，但因為 right\_max 已經在那擋著，左邊溢不出去。  
       * **貪婪策略**：每一輪我們只移動較矮的那一側指標，這樣可以保證我們始終在處理「目前已知的最小邊界」，從而實現一次遍歷完成所有計算。  
       * **同時考慮當前格 (Cell i)**： **在移動最短側的指標時，同步計算水量**。在每一輪中，我們是先更新該側的 max 值（如 left\_max），再計算水量。如果當前格 height\[left\] 剛好是目前最高的牆，更新後 left\_max 會等於 height\[left\]，此時公式 left\_max \- height\[left\] 結果為 0，這符合邏輯（最高點無法接水）。如果當前格比 left\_max 矮，代表它是一個「窪地」，此時的 left\_max 就是我們剛才確定的「瓶頸高度」，直接扣除當前高度即為該格水量。  
* **單調堆疊 (Monotonic Stack)**：另一種處理邊界與凹陷問題的高級技巧。  
  * **聯想邏輯**：  
    1. **找尋「凹」地**：接水的物理前提是必須存在一個「低洼處」。在陣列中，這表現為高度先下降再上升。  
    2. **維護下降趨勢**：我們可以使用一個堆疊來儲存柱子的索引。只要新柱子比堆疊頂部的柱子矮（或相等），表示目前還在「下降」或「平坦」階段，暫時無法接水，將其入棧。  
    3. **觸發結算**：一旦發現目前柱子 $height\[i\]$ 比堆疊頂部高，就說明我們找到了一個「右邊界」。此時，堆疊頂部就是「凹槽底部」，而堆疊頂部下方的那個元素就是「左邊界」。  
    4. **橫向計算**：與 DP 不同，堆疊法是「一層一層」橫向計算水量的。每一層的高度差乘上左右邊界的距離，就是該層的貢獻。

## **3\. 思路邏輯：如何算出「一格」的水量？**

要計算總水量，最直覺的方式時計算 **「每一格上面能放多少水」**，最後再全部加總。

對於索引為 i 的位置，它能承載的水量取決於：

1. 其左側所有柱子的最高高度 left\_max。  
2. 其右側所有柱子的最高高度 right\_max。  
3. 該位置本身的高度 height\[i\]。

邏輯公式：  
該格水量 \= $\\max(0, \\min(left\\\_max, right\\\_max) \- height\[i\])$  
**白話解讀**：水往低處流，兩邊牆壁「較短的那一方」決定了水位高度。水位減去該地表高度，就是該格的積水量。

## **4\. 解法**

### **解法一、雙指標 (Two Pointers) \- 最優解**

思路：  
利用左右兩個指標向中間靠攏。我們不需要知道完整的 left\_max 陣列，只要知道當前那一側的極限值即可。如果 height\[left\] \< height\[right\]，則左側的水位受限於左邊的牆，反之亦然。

* **時間複雜度**：$O(n)$，僅需掃描一次。  
* **空間複雜度**：$O(1)$，不需額外陣列。

def trap(height):  
    if not height: return 0  
      
    left, right \= 0, len(height) \- 1  
    left\_max, right\_max \= 0, 0  
    total\_water \= 0  
      
    while left \< right:  
        if height\[left\] \< height\[right\]:  
            \# 當前左側高度較小，處理左側  
            if height\[left\] \>= left\_max:  
                left\_max \= height\[left\] \# 更新左側最大牆高  
            else:  
                total\_water \+= left\_max \- height\[left\] \# 計算水量  
            left \+= 1  
        else:  
            \# 當前右側高度較小，處理右側  
            if height\[right\] \>= right\_max:  
                right\_max \= height\[right\] \# 更新右側最大牆高  
            else:  
                total\_water \+= right\_max \- height\[right\] \# 計算水量  
            right \-= 1  
              
    return total\_water

### **解法二：單調堆疊 (Monotonic Stack)**

思路：  
維護一個遞減堆疊。當遇到較大的柱子時，彈出堆疊頂部並計算該層的水量。  
def trap(height):  
    stack \= \[\]  
    total\_water \= 0  
    for i in range(len(height)):  
        while stack and height\[i\] \> height\[stack\[-1\]\]:  
            bottom\_index \= stack.pop()  
            if not stack: break \# 沒有左邊界，接不了水  
              
            left\_index \= stack\[-1\]  
            \# 寬度是兩牆距離  
            width \= i \- left\_index \- 1  
            \# 高度是兩牆較矮者減去底部高度  
            h \= min(height\[i\], height\[left\_index\]) \- height\[bottom\_index\]  
            total\_water \+= width \* h  
              
        stack.append(i)  
    return total\_water

## **5\. 總結**

* **暴力法**：$O(n^2)$，對每一格重複掃描左右最大值。  
* **DP 法**：$O(n)$ 時間 / $O(n)$ 空間，經典的空間換時間。  
* **雙指標法**：$O(n)$ 時間 / $O(1)$ 空間，面試最理想的答案。  
* **單調堆疊**：$O(n)$ 時間 / $O(n)$ 空間。優點是可以處理更複雜的區間計算問題，核心在於「一層一層」地填水。
