# **LeetCode 15\. 3Sum 解題攻略**

## **1\. 題目敘述 (Problem Description)**

題目名稱：3Sum (三數之和)  
難度：Medium (中等)  
描述：  
給定一個包含 n 個整數的陣列 nums，判斷 nums 中是否存在三個元素 a, b, c ，使得 a \+ b \+ c \= 0？請找出所有和為 0 且不重複的三元組。  
**注意**：答案中不可以包含重複的三元組 (例如 \[-1, 0, 1\] 和 \[0, 1, \-1\] 視為同一組，只需回傳其中一種順序，通常題目會自動判定)。

**範例**：

* **Example 1**:  
  * **Input**: nums \= \[-1, 0, 1, 2, \-1, \-4\]  
  * **Output**: \[\[-1, \-1, 2\], \[-1, 0, 1\]\]  
  * **Explanation**:  
    * nums\[0\] \+ nums\[1\] \+ nums\[2\] \= (-1) \+ 0 \+ 1 \= 0  
    * nums\[1\] \+ nums\[2\] \+ nums\[4\] \= 0 \+ 1 \+ (-1) \= 0  
    * nums\[0\] \+ nums\[3\] \+ nums\[4\] \= (-1) \+ 2 \+ (-1) \= 0  
    * 不重複的組合為 \[-1, 0, 1\] 和 \[-1, \-1, 2\]。  
* **Example 2**:  
  * **Input**: nums \= \[0, 1, 1\]  
  * **Output**: \[\]  
  * **Explanation**: 沒有任何三個數相加為 0。  
* **Example 3**:  
  * **Input**: nums \= \[0, 0, 0\]  
  * **Output**: \[\[0, 0, 0\]\]

**限制條件**：

* 3 \<= nums.length \<= 3000  
* \-10^5 \<= nums\[i\] \<= 10^5

限制條件與複雜度分析：  
根據 nums.length \<= 3000 這項限制，我們可以反推可接受的時間複雜度：

* 若使用 $O(N^3)$ 的演算法，運算量約為 $3000^3 \= 2.7 \\times 10^{10}$，這遠超過一般線上判題系統 (Online Judge) 的每秒運算極限 (通常約 $10^8$ 次操作)，肯定會導致 **Time Limit Exceeded (TLE)**。  
* 若使用 $O(N^2)$ 的演算法，運算量約為 $3000^2 \= 9 \\times 10^6$，這在運算安全範圍內。  
* 因此，看到 $N=3000$，我們就應該直覺反應出這題的目標是將解法優化至 $O(N^2)$。

## **2\. 測驗目的 (Educational Purpose)**

這道題目在面試中非常經典，主要測試應試者以下幾個能力：

1. **陣列操作與排序 (Array Manipulation & Sorting)**：  
   * 了解如何透過預處理（如排序）來降低後續搜尋的複雜度。  
2. **雙指針技巧 (Two Pointers)**：  
   * 這是本題的最佳解法核心。測試者是否能將 $O(N^3)$ 的暴力解優化為 $O(N^2)$。  
   * 理解如何在有序陣列中移動左右指針來逼近目標值。  
3. **處理重複元素 (Handling Duplicates)**：  
   * 題目要求「不重複」的三元組，這考驗邏輯細膩度。如何在遍歷過程中有效地跳過重複值，而不是事後才用 Set 去重（這會增加時間與空間成本），是高分關鍵。

## **3\. 思路邏輯 (Thought Process)**

### **3.1 為什麼暴力法 (Brute Force) 不行？**

最直觀的想法是使用三層迴圈：

for i in 0..n  
  for j in i+1..n  
    for k in j+1..n  
      check if nums\[i\] \+ nums\[j\] \+ nums\[k\] \== 0

這樣的時間複雜度是 $O(N^3)$。題目給定 $N$ 可達 3000，$3000^3 \= 2.7 \\times 10^{10}$，這絕對會 **Time Limit Exceeded (TLE)**。我們必須將複雜度降至 $O(N^2)$ 左右。

### **3.2 優化策略：排序 \+ 雙指針 (Sorting \+ Two Pointers)**

核心概念：  
如果我們將陣列先排序 (Sorting)，整個問題就會變得規律很多：  
**為什麼會直覺想到要排序？**

1. **賦予數據方向性**：在未排序的陣列中，數據是雜亂無章的，我們無法判斷「下一個數」會讓總和變大還是變小，因此只能盲目嘗試所有組合。但排序後，陣列具備了單調性（左邊小、右邊大）。  
2. **決策而非猜測**：有了單調性，我們就能根據當前的總和與目標的差距，做出有邏輯的決策——「總和太小就往右找更大的數，總和太大就往左找更小的數」。這種依據條件移動指針的能力，是將複雜度從指數級或 $O(N^3)$ 降下來的關鍵。  
3. **成本效益極高**：排序的成本僅需 $O(N \\log N)$，相較於我們想要避免的 $O(N^3)$ 暴力解，這點預處理的代價微乎其微，卻能為後續的搜尋提供巨大的便利。

接下來的操作步驟如下：

1. **固定一個數**：我們先遍歷陣列，固定第一個數 nums\[i\]。  
2. **尋找另外兩個數**：剩下的問題就變成「在 i+1 到結尾的區間內，尋找兩個數 L 和 R，使得 nums\[L\] \+ nums\[R\] \= \-nums\[i\]」。這其實就是經典的 **2Sum** 問題（但在有序陣列中可以用雙指針解）。  
3. **雙指針移動**：  
   * 令左指針 L \= i \+ 1，右指針 R \= n \- 1。  
   * 計算 sum \= nums\[i\] \+ nums\[L\] \+ nums\[R\]。  
   * 若 sum \> 0：代表總和太大，因為陣列已排序，我們需要讓數字變小，所以**右指針左移** (R--)。  
   * 若 sum \< 0：代表總和太小，我們需要讓數字變大，所以**左指針右移** (L++)。  
   * 若 sum \== 0：找到一組解！將其加入答案，並同時移動左右指針繼續尋找其他可能。

### **3.3 關鍵難點：如何去重 (De-duplication)？**

這是這題最容易寫錯的地方。若輸入是 \[-1, \-1, \-1, 2, 2\]，我們很容易找到多次 \[-1, \-1, 2\]。  
解決方案有兩處需要去重：

1. **外層迴圈 (i) 去重**：當我們移動 i 時，如果 nums\[i\] \== nums\[i-1\]，代表這個數字剛剛已經當過「第一個數」找過答案了，再做一次只會得到重複的結果，因此直接 continue 跳過。  
   * 注意！這裡要讓外層迴圈的數值 "**保持是三元組中的最小值**"，因此要用 "**在並非第 0 點(\>=1)時，該點與上一個點是否相同**" 作為剔除條件  
1. **雙指針 (L, R) 去重**：當找到一組解 (sum \== 0\) 後，在移動 L 和 R 之前，要檢查 nums\[L\] 是否等於 nums\[L+1\] 以及 nums\[R\] 是否等於 nums\[R-1\]，如果是則持續移動，直到數值改變為止。詳細說明：  
   為什麼需要這一步？假設排序後的陣列片段為 \[-2, 0, 0, 2, 2\]，且 nums\[i\] \= \-2。  
   * 當我們找到第一組 \[-2, 0, 2\] (由左邊第一個 0 和右邊最後一個 2 組成) 後，如果不跳過接下來重複的 0 和 2，指針只是單純移動一格 (L++, R--)，那麼下一輪指針仍會指向 0 和 2。  
   * 這會導致程式再次記錄 \[-2, 0, 2\]，造成答案重複。  
   * 因此，必須使用 while 迴圈將 L 移到連續重複數字的最後一個，R 移到連續重複數字的第一個，確保下一次移動後計算的組合是全新的數值。  
   * 因此先 "**比較left \< right**" 的條件確保不越界，接著比較 "**當前左index的下一個，當前右index的上一個**" 以跳過重複者，"**最後再往下移動指標"**

時間複雜度為 $O(N^2)$，空間複雜度為 $O(1)$ (不計輸出空間)。

### **複雜度分析**

* **時間複雜度 (Time Complexity)**: $O(N^2)$  
  * 排序花費 $O(N \\log N)$。  
  * 外層迴圈遍歷 $N$ 次，內層雙指針最多遍歷 $N$ 次，總共 $O(N^2)$。  
  * 整體為 $O(N^2)$，這在 $N=3000$ 的限制下是可以通過的。  
* **空間複雜度 (Space Complexity)**: $O(1)$ 或 $O(N)$  
  * 取決於排序演算法的實作空間 (Python 的 Timsort 通常需要 $O(N)$，但在演算法分析常忽略排序的空間或是視為 $O(\\log N)$)，除此之外我們只使用了常數級別的額外變數。
