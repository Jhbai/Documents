# **LeetCode 238\. Product of Array Except Self 深度解析**

## **1\. 題目目的**

給定一個整數陣列 nums，回傳一個陣列 answer，其中 answer\[i\] 必須等於 nums 中除 nums\[i\] 之外其餘所有元素的乘積。

**限制條件：**

* **時間複雜度：** 必須達到 $O(n)$。這是題目明確指定的硬性限制，旨在排除使用雙重迴圈（$O(n^2)$）的暴力解法。  
* **操作限制：** **禁止使用除法**。  
* **空間複雜度（進階）：** 除了輸出的結果陣列外，是否能以 $O(1)$ 的額外空間完成？

## **2\. 測驗目的**

這道題目主要測試開發者以下能力：

* **預計算技巧 (Pre-computation)：** 了解如何透過快取中間結果（如 Prefix/Suffix）來優化重複計算。  
  * **從暴力法出發的思路轉換：** 在暴力解法中，對於每個索引 $i$，我們都會重新遍歷整個陣列來計算乘積，這導致了大量的「重複計算」。例如計算 $i$ 的乘積與 $i+1$ 的乘積時，中間絕大部分的乘積過程是重疊的。  
  * **邏輯核心：** 預計算的本質是「空間換時間」。透過一次性的線性掃描，將「某點左側」與「某點右側」的乘積先計算好並儲存起來，將原本 $O(n^2)$ 的重複過程，簡化為 $O(1)$ 的直接查表取值。  
* **空間優化思維：** 考察如何在不增加額外陣列的情況下，利用輸出陣列作為暫存空間。  
  * **為什麼這題會特別要求空間優化？**  
    * 1\. **結構對稱性與可複寫性：** 許多演算法題目（如圖論或複雜動態規劃）的中間狀態具備強烈的依賴性，難以在不破壞原始數據的情況下進行原地更新。本本題具備以下獨特特質：  
      * **計算邏輯的線性：** 指的是計算過程僅與「前一步的結果」相關。計算 $i$ 的前綴乘積只需要「$i-1$ 的前綴乘積」乘以 nums\[i-1\]。這種單向且僅依賴前一態的特性，意味著我們不需要保留完整的歷史數據，只需一個變數就能遞歸下去。  
        * **舉例說明：** 假設陣列為 \[2, 3, 4, 5\]。計算索引 2 的左乘積時，我們已知索引 1 的左乘積是 $2 \\times 3 \= 6$，那麼索引 2 的左乘積就只是 $6 \\times 4$。我們不需要重新計算 $2 \\times 3 \\times 4$，只需拿著「當前的累計值」繼續乘以下一個數。這種「只看當下與前一步」的特性即為線性。  
      * **左右結構的對稱性：** 從左往右看的「前綴」與從右往左看的「後綴」在邏輯上是完全一致的鏡像。對於陣列中點，左邊與右邊的資訊權重相等且互相獨立。  
        * **「邏輯一致」的鏡像能做什麼？** 這代表我們可以用「同一套運算思維」處理兩次問題，而不需開發另一套邏輯。這在程式實作上意味著極高的**程式碼可複用性**與**低錯誤率**。我們只需證明正向邏輯正確，則反向邏輯必然成立。這種對稱性簡化了邊界條件（Boundary Conditions）的處理，讓我們只需關注如何「將兩次一樣的過程疊加」，而不用擔心兩者間存在複雜的非對稱衝突。  
      * **線性與對稱的結合：** 正因為邏輯是線性的（不回頭看）且對稱的（左右互不干涉），我們才能放心地將左乘積存入結果陣列後，再次以反向線性掃描的方式，直接在同一個空間將右乘積「疊加（乘上去）」，而不會發生數據被污染或計算衝突。  
    * 2\. **資訊無損轉換：** 在很多 $O(n)$ 題目中，計算下一個狀態需要前一個狀態的多個維度資訊，必須開闢新空間記錄。而本題只需一個純量變數（right\_product）隨掃描移動，即可完成所有右側資訊的傳遞。出題者想測試的是：當題目具備這種「流式處理（Streaming）」特質時，你是否能察覺到不需要額外資料結構就能完成任務。  
    * 3\. **鑑別基礎與進階者的分水嶺：** 基礎解法（開兩個 $O(n)$ 輔助陣列）是非常直覺的公式套用。出題者透過這個要求，是為了辨識出那些能對「變數生命週期」與「陣列存取順序」有深度掌控能力的開發者。  
* **邏輯推理：** 能否觀察出「除自身以外的乘積」等同於「左側乘積 $\\times$ 右側乘積」。  
* **特殊情況處理：** 測試對於「0」在陣列中的敏感度（雖然禁止除法避開了除以 0 的問題，但邏輯仍需考慮 0 的影響）。

## **3\. 思路邏輯與分析**

### **為什麼不能用除法？**

最直覺的解法是「先算總乘積，再除以每個位置的數」。但題目明確禁止除法，原因有二：

1. **處理 0 的問題：** 若陣列中包含一個或多個 0，除法會導致 Runtime Error 或需要極其複雜的條件判斷。  
2. **演算法鍛鍊：** 強制開發者尋找除了「總合逆向操作」外的其他邏輯。

### **核心邏輯：左與右的結合**

對於任何索引 $i$，其「除自身外的乘積」可以拆解為：

$$\\text{answer}\[i\] \= (\\text{index } 0 \\text{ 到 } i-1 \\text{ 的乘積}) \\times (\\text{index } i+1 \\text{ 到最後的乘積})$$  
我們可以稱前者為 **前綴乘積 (Prefix Product)**，後者為 **後綴乘積 (Suffix Product)**。

### **演算法步驟拆解：**

1. **正向掃描 (Left to Right)：** 走過一遍陣列，讓 ans\[i\] 記錄 $i$ 點左邊所有數字的乘積。  
2. **反向掃描 (Right to Left)：** 從最後一格走回來，用一個變數 right\_product 持續累乘右邊的數字，並將其與原本存在 ans\[i\] 裡的左側乘積相乘。

## **4\. 複雜度分析**

* **時間複雜度：** $O(n)$，因為我們只遍歷了兩次陣列。  
* **空間複雜度：** $O(1)$，如果不計入回傳的結果陣列。我們開額外使用了一個常數級別的變數 right\_product。
