# **LeetCode 56\. Merge Intervals 解題筆記**

在演算法面試中，「區間合併（Intervals）」是一個非常經典的範疇。這類題目考驗的不只是基礎的資料結構操作，更重要的是如何透過「排序」來簡化複雜的邏輯判斷。

## **1\. 題目敘述**

給定一個區間陣列 intervals，其中 $intervals\[i\] \= \[start\_i, end\_i\]$。請你合併所有重疊的區間，並回傳一個不重疊的區間陣列，該陣列需覆蓋輸入中所有的區間。

**範例 1：**

* **輸入：** intervals \= \[\[1,3\],\[2,6\],\[8,10\],\[15,18\]\]  
* **輸出：** \[\[1,6\],\[8,10\],\[15,18\]\]  
* **解釋：** 區間 \[1,3\] 和 \[2,6\] 重疊，合併為 \[1,6\]。

**範例 2：**

* **輸入：** intervals \= \[\[1,4\],\[4,5\]\]  
* **輸出：** \[\[1,5\]\]  
* **解釋：** 區間 \[1,4\] 和 \[4,5\] 被視為重疊（端點重合也算重疊）。

## **2\. 測驗目的**

這道題目主要考察以下能力：

1. **排序應用：** 能否觀察出排序（Sorting）是解決區間問題的先決條件。  
   * **為什麼與排序有關？** 區間問題的核心在於處理「重疊」。如果數據是雜亂的，任何兩個區間都可能重疊，這迫使我們必須進行兩兩比對（$O(N^2)$）。透過排序，我們可以將問題從「平面維度」降至「線性維度」。  
   * **從哪裡看出來？** **當題目要求「合併」或「找出重疊」且區間的邊界（Start, End）是關鍵時，應立即聯想排序**。題目中的範例雖然有時會給予看似有順序的輸入，但題目要求是針對「所有」區間，隱含了必須處理無序輸入的可能性。排序後，我們只需要關注「當前區間」與「前一個區間」的結束時間，邏輯會瞬間清晰。  
2. **邊界處理：** 判斷兩個區間是否重疊的準確邏輯（例如：前一個的結束時間與後一個的開始時間）。  
3. **貪婪思維（Greedy）：** 在處理當前區間時，只需考慮與前一個已合併區間的關係，而不需要掃描整個結果集。

## **3\. 思路邏輯：從敘述到解法**

### **第一步：找出重疊的痛點**

如果區間是亂序的，例如 \[\[8,10\], \[1,3\], \[2,6\]\]，我們很難知道 \[8,10\] 是否應該與之後的某個區間合併。我們必須檢查每一個區間與其他所有區間的關係，這會導致 $O(n^2)$ 的複雜度。

### **第二步：利用排序簡化問題**

如果我們**依照每個區間的「開始時間（start）」進行升序排序**，問題會變得非常直觀：

* 如果區間 $A$ 排在區間 $B$ 前面，那麼 $A$ 的開始時間一定小於等於 $B$。  
* 此時，我們只需要判斷：$A$ **的結束時間是否大於等於** $B$ **的開始時間？**  
  * **是：** 發生重疊，合併兩者。合併後的結束時間是 $max(A\_{end}, B\_{end})$。  
  * **否：** 沒有重疊，$A$ 已經確定獨立，可以放入結果集中，接下來將 $B$ 作為新的比較基準。

## **4\. 演算法步驟與實作**

1. **檢查邊界條件：** 若陣列為空，直接回傳空。  
2. **排序：** 依據區間的第一個元素（start）進行排序。  
3. **遍歷與合併：**  
   * 建立一個 res 列表存儲結果。  
   * 遍歷排序後的區間，若 res 為空或當前區間與 res 最後一個區間不重疊，則直接加入 res。  
   * 若重疊，更新 res 中最後一個區間的結束時間。

### **複雜度分析**

* **時間複雜度：** $O(N \\log N)$。主要的開銷在於排序，後續的遍歷只需 $O(N)$。  
* **空間複雜度：** $O(N)$（或 $O(\\log N)$ 取決於排序演算法的實作），用於儲存結果或排序空間。

## **5\. 總結**

處理區間問題的黃金準則通常就是「**先排序**」。一旦資料有序，我們就能將原本複雜的網狀關係轉換為線性的掃描過程，大幅提升效能並降低錯誤率。
